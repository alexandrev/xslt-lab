<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>XSLT Playground</title><link>https://blog.xsltplayground.com/</link><description>Recent content on XSLT Playground</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 28 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.xsltplayground.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecting XSLT in integration pipelines</title><link>https://blog.xsltplayground.com/posts/xslt-integration-architecture/</link><pubDate>Thu, 28 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-integration-architecture/</guid><description>&lt;p&gt;XSLT is at its best when it is treated as a focused transformation component in a wider integration architecture. You can use it inside an ESB, as part of a serverless function, or embedded in a data processing pipeline. The key is to define its responsibility clearly: XSLT should transform shape and content, not contain hidden transport logic or business workflows. With that boundary in place, the stylesheet becomes easier to test, reuse, and evolve.&lt;/p&gt;</description></item><item><title>Testing XSLT transforms for regression safety</title><link>https://blog.xsltplayground.com/posts/xslt-testing-and-regression/</link><pubDate>Tue, 26 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-testing-and-regression/</guid><description>&lt;p&gt;XSLT transformations often live at the heart of an integration flow. A small change can impact downstream systems, and because the output is just data, regressions can go unnoticed until a business process breaks. You do not need a massive testing framework to prevent this. A lightweight, repeatable testing approach with a few representative inputs can catch most issues and make changes far safer to deploy.&lt;/p&gt;
&lt;p&gt;Start by curating a compact test corpus. Choose a handful of XML inputs that represent the most important scenarios: a normal case, a case with missing optional elements, a case with unexpected or additional fields, and a case with edge values such as empty strings or special characters. Keep these documents small and focused so you can understand the expected output at a glance. Store them alongside the stylesheet to keep the transformation and tests tightly connected.&lt;/p&gt;</description></item><item><title>Transforming XML to JSON and CSV with XSLT</title><link>https://blog.xsltplayground.com/posts/xslt-xml-to-json-csv/</link><pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-xml-to-json-csv/</guid><description>&lt;p&gt;XSLT is usually associated with XML-to-XML transformations, but in integration work you often need JSON or CSV. The good news is that XSLT is perfectly capable of producing non-XML outputs when you design the stylesheet for it. The key is to choose the right output method, control whitespace carefully, and build an intermediate structure if it helps clarify the mapping. This post covers practical patterns for generating JSON and CSV from XML while keeping the stylesheet maintainable.&lt;/p&gt;</description></item><item><title>XSLT performance tuning without losing readability</title><link>https://blog.xsltplayground.com/posts/xslt-performance-tuning/</link><pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-performance-tuning/</guid><description>&lt;p&gt;Performance problems in XSLT are sneaky. The stylesheet looks clean, the output is correct, but the transform slows down as the input grows. Most of the time this is caused by expensive selections that are repeated in loops, or by deep &lt;code&gt;//&lt;/code&gt; searches that scan the entire tree more often than you expect. The good news is that you can usually fix these issues without turning the stylesheet into unreadable micro-optimizations.&lt;/p&gt;</description></item><item><title>Designing XSLT transforms with parameters and multiple inputs</title><link>https://blog.xsltplayground.com/posts/xslt-parameters-and-multiple-inputs/</link><pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-parameters-and-multiple-inputs/</guid><description>&lt;p&gt;Many real-world transformations do not run on a single XML document. You often merge a primary payload with reference data, catalog lookups, or environment configuration. Done well, this results in a clean, predictable transform. Done poorly, it becomes a maze of &lt;code&gt;document()&lt;/code&gt; calls and hidden dependencies. The difference is in how you model inputs and parameters from the start. As an integration engineer, I treat input selection and parameter design as first-class API design for the stylesheet.&lt;/p&gt;</description></item><item><title>XSLT debugging patterns that save hours</title><link>https://blog.xsltplayground.com/posts/xslt-debugging-patterns/</link><pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/xslt-debugging-patterns/</guid><description>&lt;p&gt;XSLT bugs are rarely loud. More often, a template silently matches the wrong node, a predicate filters out a value you needed, or a namespace mismatch turns an element into a ghost. The fastest fix comes from a repeatable debugging workflow that keeps your assumptions visible. Over time you learn the same patterns appear in almost every real project, whether you are cleansing XML feeds, integrating partner payloads, or generating documents. This post walks through the techniques I use as an integration engineer to debug transforms quickly without losing context.&lt;/p&gt;</description></item><item><title>Why I built an XSLT online editor for real-world work</title><link>https://blog.xsltplayground.com/posts/why-xslt-playground-online-editor/</link><pubDate>Sun, 20 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/why-xslt-playground-online-editor/</guid><description>&lt;p&gt;If you have spent years inside XPath and XSLT, you know the pain of juggling heavy desktop tools just to ship one transform. I wanted something faster: an &lt;strong&gt;XSLT online editor&lt;/strong&gt; that behaves like the lightweight browser utilities we all rely on. That is why I created &lt;a href="https://xsltplayground.com"&gt;XSLT Playground&lt;/a&gt;, a web-based editor built for realistic, multi-input scenarios instead of the single-input demos most tools target.&lt;/p&gt;
&lt;h2 id="the-gap-traditional-editors-left-open"&gt;The gap traditional editors left open&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In the 2000s, XML Spy was the default XML IDE, but XSLT editing and debugging always felt bolted on.&lt;/li&gt;
&lt;li&gt;Oracle JDeveloper and later Altova tools like MapForce improved visualization and isolated execution, yet they remained heavy, licensed, and resource-hungry.&lt;/li&gt;
&lt;li&gt;Existing “XSLT online editor” options often stop at one input document and a simple output. Real integrations rarely look that tidy.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="inspired-by-the-best-small-web-utilities"&gt;Inspired by the best small web utilities&lt;/h2&gt;
&lt;p&gt;For quick daily tasks, I still open &lt;a href="https://regex101.com"&gt;regex101&lt;/a&gt; to debug patterns, &lt;a href="https://www.base64decode.org/"&gt;base64decode.org&lt;/a&gt; to inspect payloads, and &lt;a href="https://www.epochconverter.com/"&gt;epochconverter.com&lt;/a&gt; for timestamps. They are fast, focused, and always there. XSLT deserved the same “open browser, get answers” experience.&lt;/p&gt;</description></item><item><title>Welcome to the XSLT Playground blog</title><link>https://blog.xsltplayground.com/posts/welcome-to-xslt-lab/</link><pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/posts/welcome-to-xslt-lab/</guid><description>&lt;p&gt;&lt;a href="https://xsltplayground.com"&gt;XSLT Playground&lt;/a&gt; is a browser-first XSLT editor that lets you run transforms with multiple inputs and parameters, see results instantly, and spot performance hotspots without installing anything. This blog gathers the practical pieces you need around it.&lt;/p&gt;
&lt;p&gt;What you will find here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Product updates and release notes for the playground.&lt;/li&gt;
&lt;li&gt;XSLT debugging recipes tailored to multi-parameter, real-world scenarios.&lt;/li&gt;
&lt;li&gt;Deployment notes, including the Helm chart and self-hosting guidance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to try it now, head straight to &lt;a href="https://xsltplayground.com"&gt;xsltplayground.com&lt;/a&gt;. If you want to contribute content, edit the Markdown in &lt;code&gt;site/content/&lt;/code&gt; and rebuild the site with &lt;code&gt;hugo --source site --minify&lt;/code&gt; to publish to &lt;code&gt;docs/&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>About</title><link>https://blog.xsltplayground.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.xsltplayground.com/about/</guid><description>&lt;p&gt;&lt;a href="https://xsltplayground.com"&gt;XSLT Playground&lt;/a&gt; is a browser-based XSLT editor built for realistic workloads: multiple inputs and parameters, live execution, and timing hints so you can tune your transforms without heavy desktop tooling.&lt;/p&gt;
&lt;p&gt;This site exists to give you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release notes and product updates.&lt;/li&gt;
&lt;li&gt;Short guides that mirror common integration tasks.&lt;/li&gt;
&lt;li&gt;Deployment options, including a Helm chart you can point at your own cluster.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Everything is Markdown in &lt;code&gt;site/content/&lt;/code&gt;, and the generated output lives in &lt;code&gt;docs/&lt;/code&gt; so you can publish easily via GitHub Pages alongside the chart index.&lt;/p&gt;</description></item></channel></rss>