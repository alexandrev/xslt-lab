<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Transforming XML to JSON and CSV with XSLT | XSLT Playground</title><meta name=description content="Patterns for producing modern integration formats while staying in XSLT."><meta name=google-adsense-account content="ca-pub-1549720748100858"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1549720748100858" crossorigin=anonymous></script><link rel=stylesheet href=/css/main.css></head><body class=has-ethicalads><script async src=https://media.ethicalads.io/media/client/ethicalads.min.js></script><div class=ad-bar><div class="container ad-bar-inner"><span class=muted>Sponsored</span><div class=ethical-ad data-ea-publisher=xsltplaygroundcom data-ea-type=image data-ea-style="fixedheader"></div></div></div><header class=site-header><div class="container header-grid"><div><a class=brand href=/>XSLT Playground</a><p class=tagline>Online XSLT editor built for real-world transformations.</p></div><nav><ul class=nav><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li><li><a href=https://alexandrev.github.io/xslt-lab/index.yaml>Charts</a></li></ul></nav></div></header><main class=container><article class=post><p class=eyebrow>Posts</p><h1>Transforming XML to JSON and CSV with XSLT</h1><p class=muted>24 Nov 2024</p><p class=lead>Patterns for producing modern integration formats while staying in XSLT.</p><div class=content><p>XSLT is usually associated with XML-to-XML transformations, but in integration work you often need JSON or CSV. The good news is that XSLT is perfectly capable of producing non-XML outputs when you design the stylesheet for it. The key is to choose the right output method, control whitespace carefully, and build an intermediate structure if it helps clarify the mapping. This post covers practical patterns for generating JSON and CSV from XML while keeping the stylesheet maintainable.</p><p>For JSON, the simplest method is to output text and build the JSON structure manually. This gives you precise control, but it also requires careful escaping and formatting. If you are on XSLT 3.0, use maps and arrays and let the processor serialize to JSON. This reduces string manipulation and makes your transform more robust. If you are on XSLT 1.0 or 2.0, you can still build JSON text safely by using templates that escape quotes, backslashes, and control characters.</p><p>A clear pattern is to create a template that takes a string and outputs an escaped JSON string. Then, for each object, output the property names and values with explicit commas. Keep a template to handle comma placement so you do not end up with trailing commas in arrays. This is a good place to use position checks like <code>position() != last()</code> to decide when to emit a comma. While it can look verbose, the logic is deterministic and easy to debug.</p><p>CSV output is simpler but comes with its own hazards. You need to wrap fields that contain commas, quotes, or line breaks. The common rule is to wrap the field in quotes and double any interior quotes. Again, a dedicated template to escape fields pays off. Define the column order explicitly and avoid depending on the source document order. This keeps the CSV consistent even if the XML input changes slightly. If you need multiple CSV sections, consider running two passes: one to compute the rows and one to serialize them.</p><p>An example CSV field template can look like this in XSLT 1.0:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;xsl:template</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;csv-field&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;xsl:param</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;value&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;xsl:variable</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;escaped&#34;</span> <span style=color:#a6e22e>select=</span><span style=color:#e6db74>&#34;translate($value, &#39;&amp;quot;&#39;, &#39;&amp;quot;&amp;quot;&#39;)&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;xsl:text&gt;</span>&#34;<span style=color:#f92672>&lt;/xsl:text&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;xsl:value-of</span> <span style=color:#a6e22e>select=</span><span style=color:#e6db74>&#34;$escaped&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;xsl:text&gt;</span>&#34;<span style=color:#f92672>&lt;/xsl:text&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/xsl:template&gt;</span>
</span></span></code></pre></div><p>This gives you a reusable building block and keeps the main row template readable. You can also pair it with a <code>csv-row</code> template that inserts commas between fields. The result is a clear structure where you can change column order without touching the escaping logic.</p><p>When moving between XML and JSON/CSV, consider creating a normalized intermediate structure. For example, if the input XML has a deep hierarchy but your output is a flat list, create a lightweight node set representing rows and columns first. Then serialize that representation into your target format. This approach makes the mapping more explicit and keeps string-heavy output logic confined to a small section of the stylesheet.</p><p>Testing is crucial because formatting errors are easy to miss. Validate JSON output with a JSON parser and load CSV into a spreadsheet or a small parser to confirm columns align. This is also where you will notice if a newline or a stray comma slipped in. To keep iteration fast, run your transform with a tool that allows quick input swaps and immediate output inspection.</p><p>If you want a quick way to experiment with JSON or CSV output, the online editor at <a href=https://xsltplayground.com>https://xsltplayground.com</a> is a great option. It lets you run transforms with multiple inputs and see the serialized output instantly, which makes it easy to refine your JSON and CSV strategies.</p></div><p class="muted back-link"><a href=/posts/>← Back to Posts</a></p></article></main><footer class=site-footer><div class="container footer-grid"><p>Built with Hugo · 2026-01-15</p><p class=muted>Repo: <a href=https://github.com/alexandrev/xslt-lab>alexandrev/xslt-lab</a></p></div></footer></body></html>