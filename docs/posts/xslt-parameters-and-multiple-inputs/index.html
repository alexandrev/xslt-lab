<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Designing XSLT transforms with parameters and multiple inputs | XSLT Playground</title><meta name=description content="How to structure stylesheets that consume several XML documents and stay maintainable."><meta name=google-adsense-account content="ca-pub-1549720748100858"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1549720748100858" crossorigin=anonymous></script><link rel=stylesheet href=/css/main.css></head><body class=has-ethicalads><script async src=https://media.ethicalads.io/media/client/ethicalads.min.js></script><div class=ad-bar><div class="container ad-bar-inner"><span class=muted>Sponsored</span><div class=ethical-ad data-ea-publisher=xsltplaygroundcom  data-ea-style="fixedheader"></div></div></div><header class=site-header><div class="container header-grid"><div><a class=brand href=/>XSLT Playground</a><p class=tagline>Online XSLT editor built for real-world transformations.</p></div><nav><ul class=nav><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li><li><a href=https://alexandrev.github.io/xslt-lab/index.yaml>Charts</a></li></ul></nav></div></header><main class=container><article class=post><p class=eyebrow>Posts</p><h1>Designing XSLT transforms with parameters and multiple inputs</h1><p class=muted>20 Nov 2024</p><p class=lead>How to structure stylesheets that consume several XML documents and stay maintainable.</p><div class=content><p>Many real-world transformations do not run on a single XML document. You often merge a primary payload with reference data, catalog lookups, or environment configuration. Done well, this results in a clean, predictable transform. Done poorly, it becomes a maze of <code>document()</code> calls and hidden dependencies. The difference is in how you model inputs and parameters from the start. As an integration engineer, I treat input selection and parameter design as first-class API design for the stylesheet.</p><p>Start by naming every input. Instead of embedding <code>document('config.xml')</code> in multiple templates, load each external document once near the top of the stylesheet and bind it to a global variable. This makes dependencies explicit and keeps the rest of the code focused on mapping. It also helps with testing, because you can override the URI with a parameter. A clean pattern is to define <code>xsl:param</code> values for input URIs and then bind them to <code>xsl:variable</code> values that hold the parsed documents.</p><p>The same clarity applies to parameters. Keep parameters primitive and predictable, and avoid passing in node sets unless you truly need them. A parameter should be an external knob: region, language, a feature flag, or an output format. If you have a complex decision tree, consider using a lookup XML or JSON input and then query it inside the stylesheet. This approach keeps the invocation interface stable while still letting you evolve business rules.</p><p>A simple skeleton might look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;xsl:param</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;catalog-uri&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;xsl:param</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;region&#34;</span> <span style=color:#a6e22e>select=</span><span style=color:#e6db74>&#34;&#39;us&#39;&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;xsl:variable</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;catalog&#34;</span> <span style=color:#a6e22e>select=</span><span style=color:#e6db74>&#34;document($catalog-uri)&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>From there, templates can reference <code>$catalog</code> without worrying about IO or base URIs. You can also define a named template that accepts a parameter for reuse across multiple modes. This is useful when the same output block is needed for several sections of the document but the selection context differs.</p><p>When combining multiple inputs, always anchor your lookups to a clear key. If you can, define <code>xsl:key</code> on the external document so lookups are efficient and readable. In XSLT 2.0 or 3.0, <code>xsl:for-each-group</code> and the <code>map</code> types can reduce boilerplate, but the core idea remains: make your joins explicit and deterministic. If you rely on default order or on undocumented assumptions about uniqueness, you will eventually get a hard-to-reproduce bug.</p><p>Another important integration pattern is separating parsing from formatting. For example, you might normalize all values from the various inputs into a canonical intermediate structure and then render that structure into the final output. This makes testing easier and supports future outputs such as CSV, JSON, or a secondary XML format. Even in XSLT 1.0, you can emulate this by creating result tree fragments, then processing them in a second pass if needed.</p><p>Multiple inputs also raise questions about fallbacks. Decide how you want to behave when optional data is missing. I prefer to centralize defaults in a few named templates or functions and avoid sprinkling <code>xsl:choose</code> blocks everywhere. This keeps the stylesheet readable and makes it obvious how to override the defaults later. Document your fallbacks in the code with short, clear names so a future maintainer does not have to rediscover the rules by reading the entire stylesheet.</p><p>Finally, create a small set of inputs that represent common scenarios and run them regularly. For example, have a baseline case, a case with missing reference data, and a case with unexpected elements. These are the cases that reveal poor assumptions about inputs. A fast way to iterate on these scenarios is to run the transform with a tool that lets you swap inputs and parameters quickly.</p><p>If you want to try these patterns with real inputs and multiple documents, the online editor at <a href=https://xsltplayground.com>https://xsltplayground.com</a> is built for that workflow. It lets you load multiple XML documents and parameters, see how they interact, and keep your integration logic transparent as it grows.</p></div><p class="muted back-link"><a href=/posts/>← Back to Posts</a></p></article></main><footer class=site-footer><div class="container footer-grid"><p>Built with Hugo · 2026-01-15</p><p class=muted>Repo: <a href=https://github.com/alexandrev/xslt-lab>alexandrev/xslt-lab</a></p></div></footer></body></html>